''' 
На парковке в торговом центре N мест (занумерованных от 1 до N). За день в ТЦ приезжало M автомобилей,
при этом некоторые из них длинные и занимали несколько подряд идущих парковочных мест. Для каждого 
автомобиля известно время приезда и отъезда, а так же два числа - с какого по какое парковочные места он 
занимал. Если в какой-то момент времени один автомобиль уехал с парковочного места, то место считается 
освободившимся и в тот же момент времени на его место может встать другой. 

Необходимо определить, был ли момент, в который были заняты все парковочные места и определить 
минимальное количество автомобилей, которое заняло все места. Если такого момента не было - вернуть M + 1.

Решение:
Добавим ещё один счётчик на количество автомобилей и будем обновлять минимальное количество автомобилей 
когда заняты все места 
'''

def mincarsonfullparking(cars, n):
    events = []
    for car in cars:
        timein, timeout, placefrom, placeto = car
        events.append((timein, 1, placeto - placefrom + 1))
        events.append((tiemout, -1, pflaceto - placefrom + 1))
    events.sort()
    occupied = 0
    nowcars = 0
    mincars = len(cars) + 1
    for i in range(len(events)):
        if events[i][1] == -1:
            occupied -= events[i][2]
        elif events[i][1] == 1:
            occupied += events[i][2]
        if occupied == n:
            mincars = min(mincars, nowcars)
    return mincars 

